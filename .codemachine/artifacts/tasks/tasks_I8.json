[
  {
    "task_id": "I8.T1",
    "iteration_id": "I8",
    "iteration_goal": "Prepare application for production deployment including Kubernetes manifests, monitoring setup, performance optimization, security hardening, documentation, and final end-to-end testing.",
    "description": "Create comprehensive Kubernetes manifests for production deployment. Resources: Deployment (backend application with replicas, resource limits, liveness/readiness probes), Service (ClusterIP for internal traffic), Ingress (ALB/Nginx with TLS termination, sticky sessions), ConfigMap (environment-specific configuration: database URL, Redis URL, feature flags), Secret (sensitive data: database password, OAuth secrets, JWT signing key, Stripe API key), HorizontalPodAutoscaler (target CPU 70%, custom metric for WebSocket connections). Use Kustomize for environment overlays (dev, staging, production). Configure rolling update strategy (maxSurge: 1, maxUnavailable: 0 for zero-downtime).",
    "agent_type_hint": "SetupAgent",
    "inputs": "Deployment architecture from architecture blueprint, Kubernetes best practices (resource limits, health checks, secrets), Environment configuration requirements",
    "input_files": [".codemachine/artifacts/architecture/05_Operational_Architecture.md"],
    "target_files": ["infra/kubernetes/base/deployment.yaml", "infra/kubernetes/base/service.yaml", "infra/kubernetes/base/ingress.yaml", "infra/kubernetes/base/configmap.yaml", "infra/kubernetes/base/secret.yaml", "infra/kubernetes/base/hpa.yaml", "infra/kubernetes/overlays/dev/kustomization.yaml", "infra/kubernetes/overlays/staging/kustomization.yaml", "infra/kubernetes/overlays/production/kustomization.yaml"],
    "deliverables": "Deployment manifest with 2 replicas, resource requests/limits (1GB mem, 500m CPU), Liveness probe: `/q/health/live`, readiness probe: `/q/health/ready`, Service exposing port 8080, Ingress with sticky session annotation, TLS certificate config, ConfigMap with database/Redis URLs, log level, Secret template for sensitive values (to be populated by CI/CD or external secrets operator), HPA scaling 2-10 pods based on CPU, Kustomize overlays for each environment",
    "acceptance_criteria": "`kubectl apply -k infra/kubernetes/overlays/dev` deploys to dev cluster, Deployment creates 2 pods initially, Liveness/readiness probes configured correctly (verify pod status), Ingress routes traffic to service, HPA created with correct scaling thresholds, ConfigMap mounted as environment variables in pods, Secrets referenced in deployment (values from external secret manager in prod)",
    "dependencies": [],
    "parallelizable": true,
    "done": true
  },
  {
    "task_id": "I8.T2",
    "iteration_id": "I8",
    "iteration_goal": "Prepare application for production deployment including Kubernetes manifests, monitoring setup, performance optimization, security hardening, documentation, and final end-to-end testing.",
    "description": "Set up Prometheus metrics collection and create Grafana dashboards. Configure Prometheus to scrape Quarkus `/q/metrics` endpoint (ServiceMonitor for Prometheus Operator or scrape config). Create custom business metrics in Quarkus: `scrumpoker_active_sessions`, `scrumpoker_websocket_connections`, `scrumpoker_votes_cast_total`, `scrumpoker_subscriptions_active`. Create Grafana dashboards: Application Overview (requests, errors, latency, active sessions), WebSocket Metrics (connections, message rate, disconnections), Business Metrics (active subscriptions by tier, voting activity, room creation rate), Infrastructure (pod CPU/memory, database connections, Redis hit rate). Export dashboards as JSON for version control.",
    "agent_type_hint": "SetupAgent",
    "inputs": "Observability requirements from architecture blueprint, Prometheus/Grafana patterns, Business metrics list",
    "input_files": [".codemachine/artifacts/architecture/05_Operational_Architecture.md"],
    "target_files": ["backend/src/main/java/com/scrumpoker/metrics/BusinessMetrics.java", "infra/monitoring/prometheus/servicemonitor.yaml", "infra/monitoring/grafana/dashboards/application-overview.json", "infra/monitoring/grafana/dashboards/websocket-metrics.json", "infra/monitoring/grafana/dashboards/business-metrics.json", "infra/monitoring/grafana/dashboards/infrastructure.json"],
    "deliverables": "BusinessMetrics class with Micrometer gauges/counters, ServiceMonitor configuring Prometheus to scrape app pods, 4 Grafana dashboards (exported as JSON), Dashboard panels: request rate, error rate, p95 latency, active sessions gauge, WebSocket dashboard: connection count, message throughput, reconnection rate, Business dashboard: MRR, subscription tier distribution, votes per session",
    "acceptance_criteria": "Prometheus scrapes application metrics endpoint, Custom business metrics appear in Prometheus targets, Grafana application dashboard displays request rate and latency, WebSocket dashboard shows connection count (test with active connections), Business metrics dashboard shows subscription counts by tier, Dashboards load without errors in Grafana",
    "dependencies": [],
    "parallelizable": true,
    "done": true
  },
  {
    "task_id": "I8.T3",
    "iteration_id": "I8",
    "iteration_goal": "Prepare application for production deployment including Kubernetes manifests, monitoring setup, performance optimization, security hardening, documentation, and final end-to-end testing.",
    "description": "Configure structured JSON logging for production. Set up Quarkus Logging JSON formatter. Add correlation ID (request ID) to all log entries: generate UUID on request entry, store in thread-local or request context, include in log MDC (Mapped Diagnostic Context). Propagate correlation ID across async operations (reactive streams, background jobs). Configure log levels: WARN in production, INFO in staging, DEBUG in dev. Implement request logging filter capturing: timestamp, method, path, status code, duration, correlation ID. Configure log aggregation destination (Loki, CloudWatch Logs).",
    "agent_type_hint": "BackendAgent",
    "inputs": "Logging requirements from architecture blueprint, Quarkus logging configuration, Correlation ID pattern",
    "input_files": [".codemachine/artifacts/architecture/05_Operational_Architecture.md"],
    "target_files": ["backend/src/main/resources/application.properties", "backend/src/main/java/com/scrumpoker/logging/CorrelationIdFilter.java", "backend/src/main/java/com/scrumpoker/logging/LoggingConstants.java"],
    "deliverables": "Quarkus logging configured for JSON output, CorrelationIdFilter generating and adding correlation ID to MDC, Request logging filter logging every HTTP request with correlation ID, Correlation ID propagated to WebSocket messages, Environment-specific log levels (WARN prod, INFO staging, DEBUG dev), Log aggregation endpoint configured (Loki or CloudWatch)",
    "acceptance_criteria": "Application logs in JSON format, Each log entry includes `correlationId` field, HTTP requests logged with method, path, status, duration, correlationId, Correlation ID appears consistently across multiple log entries for same request, WebSocket messages include correlationId in logs, Log level adjusts per environment",
    "dependencies": [],
    "parallelizable": true,
    "done": true
  },
  {
    "task_id": "I8.T4",
    "iteration_id": "I8",
    "iteration_goal": "Prepare application for production deployment including Kubernetes manifests, monitoring setup, performance optimization, security hardening, documentation, and final end-to-end testing.",
    "description": "Conduct performance optimization and load testing to validate NFRs. Optimize database queries: add missing indexes, use query plan analysis (EXPLAIN), implement pagination efficiently (cursor-based vs. offset). Optimize Redis usage: configure connection pooling, use pipelining for batch operations. Configure Quarkus JVM settings: heap size (1GB), GC tuning (G1GC), thread pool sizing. Create k6 load test scripts: scenario 1 (500 concurrent rooms, 10 participants each, vote casting), scenario 2 (100 subscription checkouts/min), scenario 3 (WebSocket reconnection storm). Run tests, analyze results, identify bottlenecks (database, Redis, CPU), iterate optimizations. Document performance benchmarks (p95 latency, throughput, error rate under load).",
    "agent_type_hint": "BackendAgent",
    "inputs": "Performance NFRs from architecture blueprint (500 concurrent sessions, <200ms latency), Load testing patterns (k6, JMeter)",
    "input_files": [".codemachine/artifacts/architecture/01_Context_and_Drivers.md"],
    "target_files": ["scripts/load-test-voting.js", "scripts/load-test-api.js", "docs/performance-benchmarks.md", "backend/src/main/resources/application.properties"],
    "deliverables": "k6 load test scripts for voting and API scenarios, Performance test execution and results analysis, Database index additions for slow queries, Redis connection pool configuration, JVM tuning parameters documented, Performance benchmarks document (latency, throughput, error rate)",
    "acceptance_criteria": "Load test achieves 500 concurrent sessions without errors, p95 latency <200ms for WebSocket messages under load, p95 latency <500ms for REST API endpoints, Database connection pool doesn't exhaust under load, Redis hit rate >90% for session cache, No memory leaks (heap usage stable during sustained load), Benchmarks documented in performance report",
    "dependencies": ["I8.T2"],
    "parallelizable": false,
    "done": false
  },
  {
    "task_id": "I8.T5",
    "iteration_id": "I8",
    "iteration_goal": "Prepare application for production deployment including Kubernetes manifests, monitoring setup, performance optimization, security hardening, documentation, and final end-to-end testing.",
    "description": "Implement security hardening for production. Configure security headers in HTTP responses: HSTS (max-age 31536000), Content-Security-Policy (restrict script sources), X-Frame-Options (DENY), X-Content-Type-Options (nosniff). Implement rate limiting: Redis-backed token bucket (10 req/min for anonymous, 100 req/min for authenticated users). Configure CORS (restrict allowed origins to frontend domains). Set up dependency vulnerability scanning: Snyk or Dependabot in GitHub Actions, fail build on HIGH/CRITICAL vulnerabilities. Container image scanning: Trivy scan in CI pipeline. Run OWASP ZAP dynamic scan against staging environment. Document security findings and remediation.",
    "agent_type_hint": "BackendAgent",
    "inputs": "Security requirements from architecture blueprint, OWASP Top 10 guidelines, Security scanning tools (Snyk, Trivy, ZAP)",
    "input_files": [".codemachine/artifacts/architecture/05_Operational_Architecture.md"],
    "target_files": ["backend/src/main/java/com/scrumpoker/security/SecurityHeadersFilter.java", "backend/src/main/java/com/scrumpoker/security/RateLimitingFilter.java", ".github/workflows/security-scan.yml", "docs/security-assessment.md"],
    "deliverables": "SecurityHeadersFilter adding security headers to all responses, RateLimitingFilter using Redis for rate limit enforcement, CORS configuration (allowed origins from environment variable), GitHub Actions workflow for dependency scanning (Snyk/Dependabot), GitHub Actions workflow for container scanning (Trivy), OWASP ZAP scan execution against staging, Security assessment document with findings and remediations",
    "acceptance_criteria": "HTTP responses include HSTS, CSP, X-Frame-Options headers, Rate limiting blocks requests exceeding threshold (test with curl loop), CORS blocks requests from unauthorized origins, Dependency scan runs in CI, fails on HIGH/CRITICAL vulnerabilities, Container scan runs in CI, reports vulnerabilities, ZAP scan completes without HIGH risk findings (or findings documented), Security assessment document reviewed",
    "dependencies": [],
    "parallelizable": true,
    "done": false
  },
  {
    "task_id": "I8.T6",
    "iteration_id": "I8",
    "iteration_goal": "Prepare application for production deployment including Kubernetes manifests, monitoring setup, performance optimization, security hardening, documentation, and final end-to-end testing.",
    "description": "Create comprehensive deployment and operations documentation. Documents: Deployment Guide (prerequisites, infrastructure setup, Kubernetes deployment steps, environment variable configuration, secret management), Operations Runbook (common tasks: scaling pods, viewing logs, restarting services, database backup/restore, disaster recovery), Monitoring Guide (Grafana dashboard usage, alert interpretation, Prometheus query examples), Troubleshooting Guide (common issues: WebSocket connection failures, database connection exhaustion, Redis out of memory, OAuth failures). Include step-by-step commands, screenshots of dashboards, decision trees for incident response.",
    "agent_type_hint": "DocumentationAgent",
    "inputs": "Deployment architecture from blueprint, Kubernetes manifests from I8.T1, Monitoring setup from I8.T2",
    "input_files": ["infra/kubernetes/", ".codemachine/artifacts/architecture/05_Operational_Architecture.md"],
    "target_files": ["docs/deployment-guide.md", "docs/runbooks/operations-runbook.md", "docs/runbooks/monitoring-guide.md", "docs/runbooks/troubleshooting-guide.md", "docs/runbooks/disaster-recovery.md"],
    "deliverables": "Deployment Guide with prerequisites, step-by-step deployment, verification steps, Operations Runbook with common administrative tasks, Monitoring Guide explaining dashboards and alert rules, Troubleshooting Guide with decision trees for common issues, Disaster Recovery procedures (database restore, failover)",
    "acceptance_criteria": "Deployment Guide enables new team member to deploy application, Operations Runbook includes commands for scaling, logs, restarts, Monitoring Guide explains each Grafana dashboard panel, Troubleshooting Guide covers top 5 incident scenarios, Disaster Recovery doc includes RTO/RPO definitions and procedures, All documents reviewed by DevOps lead",
    "dependencies": ["I8.T1", "I8.T2"],
    "parallelizable": false,
    "done": false
  },
  {
    "task_id": "I8.T7",
    "iteration_id": "I8",
    "iteration_goal": "Prepare application for production deployment including Kubernetes manifests, monitoring setup, performance optimization, security hardening, documentation, and final end-to-end testing.",
    "description": "Create automated smoke test suite verifying critical user journeys in production-like environment. Test scenarios: user registration (OAuth login), room creation, joining room, voting (cast vote, reveal), subscription upgrade (Stripe checkout, webhook), organization creation (Enterprise, SSO config), report export (CSV download). Use Playwright for frontend E2E tests or REST Assured + WebSocket client for backend integration. Run tests against staging environment (production mirror). Integrate into deployment pipeline (smoke tests run post-deployment, rollback if failures).",
    "agent_type_hint": "BackendAgent",
    "inputs": "Critical user journeys from product spec, Playwright or REST Assured test patterns",
    "input_files": [],
    "target_files": ["frontend/e2e/smoke-tests.spec.ts", "backend/src/test/java/com/scrumpoker/smoke/SmokeTestSuite.java", ".github/workflows/deploy-production.yml"],
    "deliverables": "Smoke test suite covering 6+ critical journeys, Tests executable against staging/production URLs (configurable), CI pipeline integration (run post-deployment), Deployment rollback on smoke test failure, Test execution report (pass/fail for each journey)",
    "acceptance_criteria": "`npm run test:smoke` runs all smoke tests against staging, OAuth login test completes successfully, Voting flow test (create room, vote, reveal) passes, Subscription upgrade test verifies Stripe integration, Report export test downloads CSV file, Tests integrated into production deployment workflow, Failed smoke test triggers rollback alert",
    "dependencies": [],
    "parallelizable": false,
    "done": false
  },
  {
    "task_id": "I8.T8",
    "iteration_id": "I8",
    "iteration_goal": "Prepare application for production deployment including Kubernetes manifests, monitoring setup, performance optimization, security hardening, documentation, and final end-to-end testing.",
    "description": "Finalize marketing website and create launch readiness checklist. Marketing site: polish landing page (hero section, feature highlights, testimonials placeholder), pricing page (tier comparison, FAQ), demo page (video or interactive demo link), blog section (first post: product announcement), SEO optimization (meta tags, sitemap, robots.txt). Launch checklist: DNS configured, SSL certificates valid, Stripe production keys configured, OAuth production apps registered (Google, Microsoft), privacy policy and terms of service published, support email/contact form functional, monitoring alerts configured, on-call schedule established, backup/restore tested, performance benchmarks validated, security scan passed, documentation complete.",
    "agent_type_hint": "SetupAgent",
    "inputs": "Marketing website structure from directory spec, Launch readiness best practices",
    "input_files": [],
    "target_files": ["marketing-site/src/pages/index.astro", "marketing-site/src/pages/pricing.astro", "marketing-site/src/pages/demo.astro", "marketing-site/public/sitemap.xml", "marketing-site/public/robots.txt", "docs/launch-checklist.md"],
    "deliverables": "Marketing website with polished pages (landing, pricing, demo, blog), SEO optimization (meta tags, Open Graph tags, sitemap), Privacy policy and Terms of Service pages, Contact form connected to support email, Launch readiness checklist with 20+ items, Checklist items verified (checkboxes marked)",
    "acceptance_criteria": "Marketing website deploys to production domain, Landing page loads in <2 seconds, mobile-responsive, Pricing page displays all tiers correctly, Demo page provides access to trial or video, SEO meta tags present (check with View Source), Privacy policy and ToS published and linked in footer, Launch checklist complete (all items checked or documented)",
    "dependencies": [],
    "parallelizable": true,
    "done": false
  }
]
