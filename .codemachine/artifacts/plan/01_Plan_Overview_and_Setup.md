# Project Plan: Scrum Poker Platform

**Version:** 1.0
**Date:** 2025-10-17
**Generated By:** Claude Sonnet 4.5

---

<!-- anchor: project-overview -->
## 1. Project Overview

<!-- anchor: goal -->
*   **Goal:** Build a lightweight, real-time Scrum Poker estimation platform for Agile teams (2-12 players) supporting anonymous play, OAuth2 authentication, tiered subscriptions (Free/Pro/Pro+/Enterprise), and WebSocket-based collaborative gameplay with comprehensive reporting and SSO for enterprise customers.

<!-- anchor: requirements-summary -->
*   **High-Level Requirements Summary:**
    *   Real-time WebSocket-based estimation gameplay with blind voting, customizable decks, and host controls
    *   Anonymous play with instant room creation (6-character IDs) and shareable links
    *   OAuth2 authentication (Google, Microsoft) with persistent user preferences and session history
    *   Enterprise SSO integration (OIDC/SAML2) with organization management and admin controls
    *   Tiered subscription model (Free with ads, Pro, Pro+, Enterprise) with Stripe payment integration
    *   Reporting and analytics (tier-dependent: basic summaries to org-wide dashboards)
    *   Responsive web application (React SPA) with mobile-first design
    *   Separate marketing website for SEO, pricing, and content
    *   Horizontal scalability supporting 500 concurrent sessions (6,000+ WebSocket connections)
    *   99.5% monthly uptime with automated deployment and monitoring

<!-- anchor: key-assumptions -->
*   **Key Assumptions:**
    *   **Tech Stack:** Quarkus reactive backend (Java 17), React 18 frontend, PostgreSQL 15+ database, Redis 7+ for caching/Pub/Sub
    *   **Deployment:** Kubernetes-based container orchestration (AWS EKS preferred) with managed services (RDS, ElastiCache)
    *   **Team:** 2-5 developers with expertise in Java/Quarkus, React, cloud-native patterns, and reactive programming
    *   **Timeline:** MVP delivery within 4-6 months with iterative feature releases
    *   **Scale:** Target 500 concurrent sessions at launch, with auto-scaling to handle growth
    *   **Compliance:** GDPR and basic data protection requirements (SOC2/HIPAA not required in initial release)
    *   **Browser Support:** Modern evergreen browsers (Chrome, Firefox, Safari, Edge) with WebSocket and ES2020+ support
    *   **OAuth Providers:** Google and Microsoft OAuth2 endpoints maintain >99.9% uptime
    *   **Payment Gateway:** Stripe available and compliant in target markets (North America, Europe)

---

<!-- anchor: core-architecture -->
## 2. Core Architecture

<!-- anchor: architectural-style -->
*   **Architectural Style:** Modular Monolith with Event-Driven Reactive Patterns

    **Rationale:**
    *   **Modular Monolith:** Balances operational simplicity (single deployable artifact) with clear module boundaries (User Management, Room Management, Billing, Reporting) for future microservice extraction if needed
    *   **Event-Driven Reactive:** Quarkus reactive runtime (Vert.x-based) enables non-blocking I/O for handling thousands of concurrent WebSocket connections efficiently
    *   **Redis Pub/Sub:** Enables stateless application nodes to broadcast room events across all connected clients in distributed deployment
    *   **CQRS-Lite:** Separate read models for reporting queries to avoid impacting transactional write performance

<!-- anchor: technology-stack -->
*   **Technology Stack:**
    *   **Frontend:**
        *   Framework: React 18+ with TypeScript
        *   UI Library: Tailwind CSS + Headless UI
        *   State Management: Zustand (client state) + React Query (server state)
        *   WebSocket: Native WebSocket API with reconnection wrapper
    *   **Backend:**
        *   Framework: Quarkus 3.x (Reactive mode)
        *   Language: Java 17 (LTS)
        *   Runtime: JVM mode (potential future native compilation)
    *   **Database:**
        *   Primary: PostgreSQL 15+ (ACID compliance, JSONB support, partitioning)
        *   ORM: Hibernate Reactive + Panache repositories
    *   **Messaging/Queues:**
        *   Redis 7+ Cluster (Pub/Sub for WebSocket broadcasting, Streams for async jobs)
    *   **Deployment:**
        *   Containerization: Docker (multi-stage builds)
        *   Orchestration: Kubernetes (AWS EKS or GCP GKE)
        *   Cloud Platform: AWS (primary) with CloudFront CDN, RDS, ElastiCache
    *   **Other Key Libraries/Tools:**
        *   **Auth:** Quarkus OIDC extension (OAuth2/SSO), SmallRye JWT
        *   **Payments:** Stripe Java SDK
        *   **Logging:** SLF4J with JSON formatter, Loki/CloudWatch aggregation
        *   **Metrics:** Prometheus + Grafana dashboards
        *   **Testing:** Testcontainers (integration), Playwright (E2E), JUnit 5

<!-- anchor: key-components -->
*   **Key Components/Services:**
    *   **REST Controllers:** HTTP endpoints for user management, room CRUD, subscriptions, reporting
    *   **WebSocket Handlers:** Real-time connection managers for `/ws/room/{roomId}` endpoints
    *   **Domain Services:**
        *   User Service (registration, profile, preferences)
        *   Room Service (creation, configuration, join logic)
        *   Voting Service (vote casting, reveal, consensus calculation)
        *   Billing Service (subscription tier enforcement, Stripe integration)
        *   Reporting Service (session aggregation, analytics, export)
        *   Organization Service (SSO config, member management, admin controls)
    *   **Repository Layer:** Panache repositories for User, Room, Vote, Session, Subscription, Organization entities
    *   **Integration Adapters:** OAuth2 client, SSO adapter, Stripe adapter, Email adapter
    *   **Event Publisher/Subscriber:** Redis Pub/Sub client for WebSocket message broadcasting
    *   **Background Worker:** Async job processor for report generation, email dispatch

    **Key Diagrams Planned:**
    *   Component Diagram (PlantUML) - Visualizes internal Quarkus application structure (Created in Architecture Blueprint reference)
    *   Sequence Diagram - Vote casting and reveal flow (Created in Architecture Blueprint reference)

<!-- anchor: data-model-overview -->
*   **Data Model Overview:**

    **Core Entities (11 tables):**
    1. **User** - Registered user accounts (OAuth provider, subscription tier, profile)
    2. **UserPreference** - Saved defaults (deck type, theme, room settings)
    3. **Organization** - Enterprise workspaces (SSO config, branding)
    4. **OrgMember** - User-organization membership with roles
    5. **Room** - Estimation sessions (6-char ID, privacy mode, config JSONB)
    6. **RoomParticipant** - Active session participants (anonymous or authenticated)
    7. **Round** - Estimation rounds within session (story, votes, consensus)
    8. **Vote** - Individual card selections per round
    9. **SessionHistory** - Completed session records with summary stats
    10. **Subscription** - Stripe subscription records (tier, status, billing cycle)
    11. **PaymentHistory** - Payment transaction log
    12. **AuditLog** - Enterprise compliance trail (partitioned by month)

    **Design Principles:**
    *   Normalized core entities (3NF) for transactional consistency
    *   JSONB columns for flexible configuration (room settings, deck definitions)
    *   Soft deletes (`deleted_at`) for audit trail and GDPR compliance
    *   Partitioning for SessionHistory and AuditLog (monthly range partitions)

    **Key Diagram Planned:**
    *   Entity Relationship Diagram (PlantUML ERD) - Shows relationships and cardinality (Created in Architecture Blueprint reference)

<!-- anchor: api-contract-style -->
*   **API Contract Style:**
    *   **REST API:** RESTful JSON API documented with OpenAPI 3.1 specification
        *   URL versioning: `/api/v1/`
        *   Standard HTTP semantics (GET, POST, PUT, DELETE)
        *   Error responses with consistent structure (4xx client errors, 5xx server errors)
    *   **WebSocket Protocol:** Custom JSON-RPC style over WebSocket
        *   Message format: `{"type": "vote.cast.v1", "requestId": "uuid", "payload": {...}}`
        *   Versioned message types (e.g., `v1`, `v2`) for protocol evolution
        *   Request/response correlation via `requestId`

    **Planned Specification Files:**
    *   OpenAPI 3.1 Specification (YAML) - Documents all REST endpoints (Created in I2.T1)
    *   WebSocket Protocol Specification (Markdown) - Message type catalog with JSON schemas (Created in I2.T2)

<!-- anchor: communication-patterns -->
*   **Communication Patterns:**
    *   **Synchronous REST (Request/Response):** User authentication, room CRUD, subscription management, report triggers
    *   **Asynchronous WebSocket (Event-Driven):** Real-time vote casting, room state sync, presence updates, chat
    *   **Asynchronous Job Processing (Fire-and-Forget):** Report exports, email notifications, analytics aggregation

    **Event Flow (WebSocket):**
    1. Client sends message to WebSocket handler
    2. Handler validates, persists to PostgreSQL
    3. Handler publishes event to Redis Pub/Sub channel `room:{roomId}`
    4. All application nodes subscribed to channel receive event
    5. Each node broadcasts to locally connected clients in that room

    **Relevant Sequence Diagrams:**
    *   Vote Casting & Round Reveal (Created in Architecture Blueprint reference)
    *   OAuth2 Authentication Flow (Created in Architecture Blueprint reference)

---

<!-- anchor: key-architectural-artifacts -->
## 2.1. Key Architectural Artifacts Planned

*   **Component Diagram (PlantUML)** - Visualizes internal structure of Quarkus application showing REST controllers, WebSocket handlers, domain services, repositories, and integration adapters
    *   **Purpose:** Clarify module boundaries and dependencies for development team
    *   **Format:** PlantUML C4 Component diagram
    *   **Created:** Reference Architecture Blueprint (already exists in `.codemachine/artifacts/architecture/`)

*   **Sequence Diagram: Vote Casting & Round Reveal (PlantUML)** - End-to-end flow showing WebSocket message handling, Redis Pub/Sub broadcasting, and database persistence
    *   **Purpose:** Document critical real-time interaction pattern for developers implementing voting logic
    *   **Format:** PlantUML sequence diagram
    *   **Created:** Reference Architecture Blueprint

*   **Sequence Diagram: OAuth2 Authentication (PlantUML)** - Authorization code flow with PKCE for Google/Microsoft login
    *   **Purpose:** Guide frontend and backend teams on OAuth integration
    *   **Format:** PlantUML sequence diagram
    *   **Created:** Reference Architecture Blueprint

*   **Entity Relationship Diagram (PlantUML ERD)** - Complete database schema with 11+ entities, relationships, and key attributes
    *   **Purpose:** Database design reference for schema migration scripts and repository implementation
    *   **Format:** PlantUML ERD
    *   **Created:** Reference Architecture Blueprint

*   **OpenAPI 3.1 Specification (YAML)** - Complete REST API contract with request/response schemas, authentication requirements, error codes
    *   **Purpose:** Enable TypeScript client SDK generation, API documentation (Swagger UI), contract testing
    *   **Format:** OpenAPI 3.1 YAML
    *   **Created:** I2.T1 (Iteration 2, Task 1)

*   **WebSocket Protocol Specification (Markdown)** - Message type catalog with JSON schemas, versioning strategy, error codes
    *   **Purpose:** Define WebSocket contract for frontend/backend coordination
    *   **Format:** Markdown document with embedded JSON schemas
    *   **Created:** I2.T2 (Iteration 2, Task 2)

*   **Database Migration Scripts (SQL DDL)** - Flyway/Liquibase migration files for schema creation and evolution
    *   **Purpose:** Automate database schema deployment across environments
    *   **Format:** SQL DDL with version numbering (V1__initial_schema.sql)
    *   **Created:** I1.T3 (Iteration 1, Task 3)

*   **Deployment Diagram (PlantUML C4)** - AWS production architecture showing VPC, EKS cluster, RDS, ElastiCache, load balancers
    *   **Purpose:** Infrastructure planning and DevOps reference
    *   **Format:** PlantUML C4 Deployment diagram
    *   **Created:** Reference Architecture Blueprint

---

<!-- anchor: directory-structure -->
## 3. Directory Structure

*   **Root Directory:** `scrum-poker-platform/`

*   **Structure Definition:**

    The project follows a standard Maven multi-module structure for the backend and modern React SPA conventions for the frontend, with clear separation of concerns and dedicated locations for documentation, API specifications, and infrastructure-as-code.

    ~~~
    scrum-poker-platform/
    ├── backend/                          # Quarkus backend application
    │   ├── src/
    │   │   ├── main/
    │   │   │   ├── java/
    │   │   │   │   └── com/scrumpoker/
    │   │   │   │       ├── api/          # REST controllers, WebSocket handlers
    │   │   │   │       │   ├── rest/     # JAX-RS resource classes
    │   │   │   │       │   └── websocket/ # WebSocket endpoint handlers
    │   │   │   │       ├── domain/       # Domain services and business logic
    │   │   │   │       │   ├── user/     # User, UserPreference entities + service
    │   │   │   │       │   ├── room/     # Room, Round, Vote entities + service
    │   │   │   │       │   ├── billing/  # Subscription, Payment entities + service
    │   │   │   │       │   ├── reporting/ # SessionHistory, analytics service
    │   │   │   │       │   └── organization/ # Organization, OrgMember entities + service
    │   │   │   │       ├── repository/   # Panache repositories
    │   │   │   │       ├── integration/  # External service adapters
    │   │   │   │       │   ├── oauth/    # Google/Microsoft OAuth2 clients
    │   │   │   │       │   ├── sso/      # OIDC/SAML2 adapters
    │   │   │   │       │   ├── stripe/   # Stripe SDK wrapper
    │   │   │   │       │   └── email/    # SendGrid/SES client
    │   │   │   │       ├── event/        # Redis Pub/Sub publisher/subscriber
    │   │   │   │       ├── config/       # Application configuration classes
    │   │   │   │       └── security/     # Authentication filters, JWT utilities
    │   │   │   └── resources/
    │   │   │       ├── application.properties  # Quarkus configuration
    │   │   │       └── db/
    │   │   │           └── migration/    # Flyway SQL migration scripts
    │   │   │               ├── V1__initial_schema.sql
    │   │   │               ├── V2__add_organizations.sql
    │   │   │               └── ...
    │   │   └── test/
    │   │       ├── java/
    │   │       │   └── com/scrumpoker/
    │   │       │       ├── api/          # REST/WebSocket integration tests
    │   │       │       ├── domain/       # Unit tests for services
    │   │       │       └── repository/   # Repository tests with Testcontainers
    │   │       └── resources/
    │   │           └── application-test.properties
    │   ├── pom.xml                       # Maven project descriptor
    │   └── Dockerfile                    # Multi-stage Docker build
    │
    ├── frontend/                         # React SPA
    │   ├── public/
    │   │   ├── index.html
    │   │   └── favicon.ico
    │   ├── src/
    │   │   ├── components/               # Reusable UI components
    │   │   │   ├── common/               # Buttons, modals, forms
    │   │   │   ├── room/                 # Room lobby, voting card, reveal
    │   │   │   ├── auth/                 # Login, OAuth callback
    │   │   │   └── dashboard/            # User dashboard, settings
    │   │   ├── pages/                    # Route-level page components
    │   │   │   ├── HomePage.tsx
    │   │   │   ├── RoomPage.tsx
    │   │   │   ├── DashboardPage.tsx
    │   │   │   └── SettingsPage.tsx
    │   │   ├── services/                 # API clients and WebSocket manager
    │   │   │   ├── api.ts                # REST API client (React Query)
    │   │   │   └── websocket.ts          # WebSocket connection manager
    │   │   ├── stores/                   # Zustand state stores
    │   │   │   ├── authStore.ts
    │   │   │   ├── roomStore.ts
    │   │   │   └── uiStore.ts
    │   │   ├── types/                    # TypeScript type definitions
    │   │   │   ├── api.ts                # API DTOs (generated from OpenAPI)
    │   │   │   └── websocket.ts          # WebSocket message types
    │   │   ├── utils/                    # Utility functions
    │   │   ├── App.tsx                   # Root component with routing
    │   │   ├── index.tsx                 # Entry point
    │   │   └── tailwind.config.js        # Tailwind CSS configuration
    │   ├── package.json
    │   ├── tsconfig.json
    │   └── vite.config.ts                # Vite build configuration
    │
    ├── marketing-site/                   # Separate static marketing website
    │   ├── src/
    │   │   ├── pages/
    │   │   │   ├── index.astro           # Landing page
    │   │   │   ├── pricing.astro
    │   │   │   ├── demo.astro
    │   │   │   └── blog/
    │   │   ├── components/
    │   │   └── layouts/
    │   ├── public/
    │   │   └── assets/
    │   ├── astro.config.mjs              # Astro framework configuration
    │   └── package.json
    │
    ├── docs/                             # Documentation and design artifacts
    │   ├── architecture/                 # System architecture blueprint (reference)
    │   │   ├── 01_Context_and_Drivers.md
    │   │   ├── 02_Architecture_Overview.md
    │   │   ├── 03_System_Structure_and_Data.md
    │   │   ├── 04_Behavior_and_Communication.md
    │   │   ├── 05_Operational_Architecture.md
    │   │   ├── 06_Rationale_and_Future.md
    │   │   └── architecture_manifest.json
    │   ├── diagrams/                     # UML and architectural diagrams
    │   │   ├── component_diagram.puml
    │   │   ├── sequence_vote_flow.puml
    │   │   ├── sequence_oauth.puml
    │   │   ├── erd.puml
    │   │   └── deployment_aws.puml
    │   ├── adr/                          # Architectural Decision Records
    │   │   ├── 001-modular-monolith.md
    │   │   ├── 002-quarkus-reactive.md
    │   │   └── ...
    │   └── runbooks/                     # Operational runbooks
    │       ├── deployment.md
    │       ├── disaster-recovery.md
    │       └── scaling.md
    │
    ├── api/                              # API specifications
    │   ├── openapi.yaml                  # OpenAPI 3.1 REST API spec
    │   └── websocket-protocol.md         # WebSocket message catalog
    │
    ├── infra/                            # Infrastructure as Code
    │   ├── kubernetes/                   # Kubernetes manifests
    │   │   ├── base/
    │   │   │   ├── deployment.yaml
    │   │   │   ├── service.yaml
    │   │   │   ├── ingress.yaml
    │   │   │   ├── configmap.yaml
    │   │   │   └── hpa.yaml              # HorizontalPodAutoscaler
    │   │   ├── overlays/
    │   │   │   ├── dev/
    │   │   │   ├── staging/
    │   │   │   └── production/
    │   │   └── kustomization.yaml
    │   ├── terraform/                    # AWS infrastructure (optional)
    │   │   ├── main.tf
    │   │   ├── vpc.tf
    │   │   ├── eks.tf
    │   │   ├── rds.tf
    │   │   └── elasticache.tf
    │   └── helm/                         # Helm chart (alternative to raw K8s)
    │       ├── Chart.yaml
    │       ├── values.yaml
    │       └── templates/
    │
    ├── scripts/                          # Utility scripts
    │   ├── generate-nanoid.js            # Room ID generator
    │   ├── seed-database.sql             # Test data seeding
    │   └── load-test.js                  # k6 load test script
    │
    ├── .github/                          # GitHub Actions CI/CD
    │   └── workflows/
    │       ├── backend-ci.yml            # Backend build, test, scan
    │       ├── frontend-ci.yml           # Frontend build, test, lint
    │       ├── deploy-staging.yml
    │       └── deploy-production.yml
    │
    ├── docker-compose.yml                # Local development environment
    ├── .gitignore
    ├── README.md                         # Project overview and setup instructions
    └── LICENSE
    ~~~

**Justifications for Key Choices:**

1. **Maven Standard Layout (backend):** Quarkus convention, familiar to Java developers, supports multi-module if needed
2. **Domain-Driven Directory Structure (backend/src/main/java/com/scrumpoker/domain/):** Clear bounded contexts (user, room, billing, reporting, organization) align with business domains and support future microservice extraction
3. **Separate `api/` Directory:** Decouples API contracts (OpenAPI spec, WebSocket protocol) from implementation, enables contract-first development and client SDK generation
4. **Dedicated `docs/` Hierarchy:** Centralizes architecture blueprints, diagrams (PlantUML source), ADRs, and runbooks for discoverability
5. **Separate `marketing-site/` Directory:** Isolates SEO-optimized static content from SPA, different deployment pipeline (static hosting vs. CDN)
6. **Infrastructure as Code (`infra/`):** Supports GitOps workflows, version-controlled Kubernetes manifests and Terraform scripts
7. **Flyway Migration Scripts (`backend/src/main/resources/db/migration/`):** Automated, version-controlled database schema evolution
8. **Component-Based Frontend (`frontend/src/components/`):** Reusable UI patterns, aligns with atomic design principles
9. **Testcontainers Support (`backend/src/test/`):** Integration tests with real PostgreSQL/Redis instances for high confidence

---

<!-- anchor: iteration-plan-summary -->
## 4. Iteration Plan

*   **Total Iterations Planned:** 8 iterations

*   **Iteration Dependencies:**

    **Linear Dependencies:**
    *   I2 (Core Backend Services) depends on I1 (Project Setup & Database Foundation)
    *   I3 (Authentication & User Management) depends on I1 (database schema) and I2 (API contracts)
    *   I4 (Real-Time Voting Engine) depends on I2 (Room Service) and I3 (User authentication)
    *   I5 (Subscription & Billing) depends on I3 (User accounts)
    *   I6 (Reporting & Analytics) depends on I4 (SessionHistory data)
    *   I7 (Enterprise Features) depends on I3 (User/Auth) and I5 (Subscription tiers)
    *   I8 (Deployment & Production Readiness) depends on all previous iterations

    **Parallel Opportunities:**
    *   Frontend development (React components) can progress alongside backend services in I2-I7 with mocked APIs
    *   Marketing website development can proceed independently after I1
    *   Infrastructure setup (Kubernetes manifests, Terraform) can start in I1 and evolve through I8

**High-Level Iteration Flow:**

```
I1: Project Setup & Database Foundation
    ↓
I2: Core Backend Services & API Contracts
    ↓
I3: Authentication & User Management ───┐
    ↓                                    │
I4: Real-Time Voting Engine             │ (Parallel frontend work)
    ↓                                    │
I5: Subscription & Billing              │
    ↓                                    │
I6: Reporting & Analytics               │
    ↓                                    │
I7: Enterprise Features (SSO & Orgs) ───┘
    ↓
I8: Deployment & Production Readiness
```

---

**Detailed iteration plans follow in separate files:**

- **Iteration 1:** [02_Iteration_I1.md](./02_Iteration_I1.md)
- **Iteration 2:** [02_Iteration_I2.md](./02_Iteration_I2.md)
- **Iteration 3:** [02_Iteration_I3.md](./02_Iteration_I3.md)
- **Iteration 4:** [02_Iteration_I4.md](./02_Iteration_I4.md)
- **Iteration 5:** [02_Iteration_I5.md](./02_Iteration_I5.md)
- **Iteration 6:** [02_Iteration_I6.md](./02_Iteration_I6.md)
- **Iteration 7:** [02_Iteration_I7.md](./02_Iteration_I7.md)
- **Iteration 8:** [02_Iteration_I8.md](./02_Iteration_I8.md)

**Verification Strategy and Glossary:** [03_Verification_and_Glossary.md](./03_Verification_and_Glossary.md)
